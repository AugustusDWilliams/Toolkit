# 25-oct-2018

### 4 - Files related to ast, parser and compilation in Cpython source tree

- ```Parser/```
  - ```Python.asdl``` : ASDL syntax file
  - ```asdl.py``` : Parser for ASDL definition files. Reads in an ASDL description and parses it into an AST that describes it.
  - ```asdl_c.py``` : “Generate C code from an ASDL description.” Generates Python/Python-ast.c and Include/Python-ast.h.
- ```Python/```
  - ```Python-ast.c``` : Creates C structs corresponding to the ASDL types. Also contains code for marshalling AST nodes (core ASDL types have marshalling code in asdl.c). “File automatically generated by Parser/asdl_c.py”. This file must be committed separately after every grammar change is committed since the ```__version__``` value is set to the latest grammar change revision number.
  - ```asdl.c``` : Contains code to handle the ASDL sequence type. Also has code to handle marshalling the core ASDL types, such as number and identifier. Used by Python-ast.c for marshalling AST nodes.
  - ```ast.c``` : Converts Python’s parse tree into the abstract syntax tree.
  - ```ast_opt.c``` : Optimizes the AST.
  - ```ast_unparse.c``` : Converts the AST expression node back into a string (for string annotations).
  - ```ceval.c``` : Executes byte code (aka, eval loop).
  - ```compile.c``` : Emits bytecode based on the AST.
  - ```symtable.c``` : Generates a symbol table from AST.
  - ```peephole.c``` : Optimizes the bytecode.
  - ```pyarena.c``` : Implementation of the arena memory manager.
  - ```wordcode_helpers.h``` : Helpers for generating bytecode.
  - ```opcode_targets.h``` : One of the files that must be modified if Lib/opcode.py is.
- ```Include/```
  - ```Python-ast.h``` : Contains the actual definitions of the C structs as generated by Python/Python-ast.c. “Automatically generated by Parser/asdl_c.py”.
  - ```asdl.h``` : Header for the corresponding Python/ast.c.
  - ```ast.h``` : Declares PyAST_FromNode() external (from Python/ast.c).
  - ```code.h``` : Header file for Objects/codeobject.c; contains definition of PyCodeObject.
  - ```symtable.h``` : Header for Python/symtable.c. struct symtable and PySTEntryObject are defined here.
  - ```pyarena.h``` : Header file for the corresponding Python/pyarena.c.
  - ```opcode.h``` : One of the files that must be modified if Lib/opcode.py is.

- ```Objects/```
  - ```codeobject.c``` : Contains PyCodeObject-related code (originally in Python/compile.c).
  - ```frameobject.c```: Contains the frame_setlineno() function which should determine whether it is allowed to make a jump between two points in a bytecode.

- ```Lib/```
  - ```opcode.py``` : Master list of bytecode; if this file is modified you must modify several other files accordingly (see “Introducing New Bytecode”)
  - ```importlib/_bootstrap_external.py```  :Home of the magic number (named MAGIC_NUMBER) for bytecode versioning.



### 3 - Python compilation

- Grammar to Parse Tree : ```parser/pgen.c```
- Parse tree to AST : ```Python/ast.c```
- AST to CFG : ```Python/compile.c``` (CFG : Control flow Graph)
- CFG to Bytecode : ```Python/compile.c``` 
- Bytecode to Machine Execution : ```Python/ceval.c```

- https://devguide.python.org/compiler/

### 2 - Accessing memory using CPython

- ctypes module gives ability to read memory directly ( only true for CPython)

```python
Python 3.5.2 (default, Nov 23 2017, 16:37:01) 
[GCC 5.4.0 20160609] on linux
Type "help", "copyright", "credits" or "license" for more information.
>>> import ctypes
>>> ctypes.c_ubyte.from_address(id(10)).value
16
>>> ctypes.c_ubyte.from_address(id(10)).value
16
>>> ctypes.c_ubyte.from_address(id(10) + 24).value
10
>>> ctypes.c_ubyte.from_address(id(10) + 24).value
10
>>> ctypes.c_ubyte.from_address(id(10) + 24).value is 10
True
>>> ctypes.c_ubyte.from_address(id(10) + 24).value = 11
>>> 10 == 11
True
>>> 10 is 11
True
>>> 
```

### 1 - Dynamic array class

- (ctypes.py_object * N) returns py_object_Array_N of type. (ctypes.pyobject * N)() creates a instance of it.
- Dynamic sizing for arrays created like this needs to be handled externally as they are of fixed size.

```python
import ctypes

class DynamicArray:
	"""A dynamic array class akin to a simpliified python list"""

	def __init__(self):
		"""Create an empty array"""
		self._n = 0 #count actual elements
		self._capacity = 1 # default array capacity
		self._A = self._make_array(self._capacity) #low level array

	def __len__(self):
		"""Return number of elements stored in the array"""
		return self._n


	def __getitem__(self,k):
		"""Return element at index k"""
		if not 0 <= k < self._n:
			raise IndexError('Invalid index')
		return self._A[k]


	def append(self,obj): #public method
		"""Add object to end of the array"""
		if self._n == self._capacity:
			self._resize(2*self._capacity)
		self._A[self._n] = obj
		self._n += 1


	def _resize(self, c):
		"""Resize internal array to capcity c"""
		B = self._make_array(c)
		for k in range(self._n):
			B[k] = self._A[k]

		self._A = B
		self._capacity = c

	def _make_array(self,c):
		"""Return new array iwth capcity c"""
		return ( c * ctypes.py_object)() #



d = DynamicArray()
d.append(10)

for x in d:
	print x
```
